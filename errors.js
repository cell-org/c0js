module.exports = {
  '0': 'require(state == 0, "0");   // cannot mint when the state is paused or frozen',
  '1': 'require(burned[body.id] == address(0), "1");    // cannot mint if it was already burned',
  '2': 'require(_hashTypedDataV4(bodyhash).recover(body.signature) == owner(), "2");    // check script signature',
  '3': 'if (body.sender != address(0)) require(body.sender == _msgSender(), "3");   // sender lock validation',
  '4': 'require(body.start <= block.timestamp, "4");    // start time lock validation',
  '5': 'require(body.end >= block.timestamp, "5");    // end time lock validation',
  '6': 'require(input.puzzle.length > 0 && keccak256(input.puzzle) == body.puzzleHash, "6");    // hash puzzle lock validation',
  '11': 'require(val == msg.value, "11");    // value lock validation',
  '15': 'require(_isApprovedOrOwner(_msgSender(), _tokenId), "15");    // only the owner or the approved can burn',
  '20': `require(!withdrawer.permanent, "20");   // only can set withdrawer if it's not yet permanent`,
  '30': 'require(_msgSender() == owner() || _msgSender() == withdrawer.account, "30");   // only the owner or the withdrawer (if set) can trigger a withdraw',
  '40': 'require(state != 2, "40");    // can set state only when the state is not frozen (2)',
  '50': 'require(state == 0, "50");    // can set baseURI only when the state is not frozen (2)',
  '60': 'require(state == 0, "60");    // can set name and symbol only when the state is not frozen (2)',
  '8a': 'require(IRelation(relation.addr).burned(relation.id) == _msgSender(), "8a");    // remote contract burnership check for sender',
  '8b': 'require(IRelation(relation.addr).burned(relation.id) == receiver, "8b");    // remote contract burnership check for receiver',
  '9a': 'require(IRelation(relation.addr).ownerOf(relation.id) == _msgSender(), "9a");   // remote contract ownership check for sender',
  '9b': 'require(IRelation(relation.addr).ownerOf(relation.id) == receiver, "9b");   // remote contract ownership check for receiver',
  '10a': 'require(IRelation(relation.addr).balanceOf(_msgSender()) >= relation.id, "10a");    // remote contract balance check for sender',
  '10b': 'require(IRelation(relation.addr).balanceOf(receiver) >= relation.id, "10b");    // remote contract balance check for receiver',
  '10c': 'require(outgoing <= 1e6, "10c");  // the sum of all payment split shares must not exceed 1,000,000 (1e6)',
  '7a': 'require(verify(body.sendersHash, input.sendersProof, _msgSender()), "7a");    // senders merkle proof lock validation',
  '7b': 'require(verify(body.receiversHash, input.receiversProof, receiver), "7b");    // receivers merkle proof lock validation',
  'ERC721Metadata: URI query for nonexistent token': 'require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");'
}
